# SuperBizAgent 代码质量提升建议

## 一、错误处理优化

### 1.1 当前问题

**现状**:
- 错误处理不统一,有些地方直接 `panic`
- 错误信息不够详细,难以定位问题
- 缺少错误分类和错误码

**代码位置**: `main.go:16-18`

```go
// 当前实现: 直接 panic
fileDir, err := g.Cfg().Get(ctx, "file_dir")
if err != nil {
    panic(err)  // 不友好的错误处理
}
```

### 1.2 改进方案

**引入统一的错误处理机制**:

```go
package errors

import (
    "fmt"
    "runtime"
)

// 错误码定义
const (
    ErrCodeConfigLoad    = 1001 // 配置加载失败
    ErrCodeDBConnect     = 2001 // 数据库连接失败
    ErrCodeMilvusConnect = 2002 // Milvus 连接失败
    ErrCodeFileUpload    = 3001 // 文件上传失败
    ErrCodeIndexBuild    = 3002 // 索引构建失败
    ErrCodeLLMCall       = 4001 // LLM 调用失败
    ErrCodeToolCall      = 4002 // 工具调用失败
)

// 业务错误
type BizError struct {
    Code    int    // 错误码
    Message string // 错误消息
    Cause   error  // 原始错误
    Stack   string // 堆栈信息
}

func (e *BizError) Error() string {
    if e.Cause != nil {
        return fmt.Sprintf("[%d] %s: %v", e.Code, e.Message, e.Cause)
    }
    return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}

// 创建业务错误
func NewBizError(code int, message string, cause error) *BizError {
    // 获取调用栈
    buf := make([]byte, 4096)
    n := runtime.Stack(buf, false)
    
    return &BizError{
        Code:    code,
        Message: message,
        Cause:   cause,
        Stack:   string(buf[:n]),
    }
}

// 包装错误
func Wrap(err error, code int, message string) error {
    if err == nil {
        return nil
    }
    return NewBizError(code, message, err)
}

// 判断错误类型
func Is(err error, code int) bool {
    if bizErr, ok := err.(*BizError); ok {
        return bizErr.Code == code
    }
    return false
}
```

**在代码中使用**:

```go
// main.go - 改进后
package main

import (
    "SuperBizAgent/internal/controller/chat"
    "SuperBizAgent/utility/common"
    "SuperBizAgent/utility/middleware"
    "SuperBizAgent/pkg/errors"
    
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/os/gctx"
    "github.com/gogf/gf/v2/os/glog"
)

func main() {
    ctx := gctx.New()
    
    // 配置加载
    fileDir, err := g.Cfg().Get(ctx, "file_dir")
    if err != nil {
        // 记录详细错误日志
        bizErr := errors.Wrap(err, errors.ErrCodeConfigLoad, "加载配置文件失败")
        glog.Fatal(ctx, bizErr)
        return
    }
    common.FileDir = fileDir.String()
    
    // 初始化服务
    if err := initServices(ctx); err != nil {
        glog.Fatal(ctx, err)
        return
    }
    
    // 启动服务器
    s := g.Server()
    s.Group("/api", func(group *ghttp.RouterGroup) {
        group.Middleware(middleware.CORSMiddleware)
        group.Middleware(middleware.ResponseMiddleware)
        group.Middleware(middleware.ErrorHandlerMiddleware) // 统一错误处理
        group.Bind(chat.NewV1())
    })
    s.SetPort(6872)
    s.Run()
}

func initServices(ctx context.Context) error {
    // 初始化 Milvus
    if err := initMilvus(ctx); err != nil {
        return errors.Wrap(err, errors.ErrCodeMilvusConnect, "Milvus 初始化失败")
    }
    
    // 初始化 MySQL
    if err := initMySQL(ctx); err != nil {
        return errors.Wrap(err, errors.ErrCodeDBConnect, "MySQL 初始化失败")
    }
    
    return nil
}
```

**统一错误处理中间件**:

```go
// utility/middleware/error_handler.go
package middleware

import (
    "SuperBizAgent/pkg/errors"
    
    "github.com/gogf/gf/v2/net/ghttp"
    "github.com/gogf/gf/v2/os/glog"
)

func ErrorHandlerMiddleware(r *ghttp.Request) {
    r.Middleware.Next()
    
    // 检查是否有错误
    if err := r.GetError(); err != nil {
        ctx := r.Context()
        
        // 记录错误日志
        if bizErr, ok := err.(*errors.BizError); ok {
            glog.Errorf(ctx, "业务错误: %v\n堆栈: %s", bizErr, bizErr.Stack)
            
            // 返回友好的错误信息
            r.Response.WriteJson(ghttp.DefaultHandlerResponse{
                Code:    bizErr.Code,
                Message: bizErr.Message,
                Data:    nil,
            })
        } else {
            // 未知错误
            glog.Errorf(ctx, "未知错误: %v", err)
            
            r.Response.WriteJson(ghttp.DefaultHandlerResponse{
                Code:    -1,
                Message: "系统错误,请稍后重试",
                Data:    nil,
            })
        }
        
        return
    }
}
```

### 1.3 改进效果

**优势**:
1. **错误可追踪**: 包含完整堆栈信息
2. **错误可分类**: 通过错误码区分不同类型
3. **错误可监控**: 统一记录和告警
4. **用户友好**: 返回清晰的错误提示

---

## 二、日志规范化

### 2.1 当前问题

**现状**:
- 日志格式不统一,有 `fmt.Printf`,有 `log.Printf`
- 缺少结构化日志
- 日志级别使用不规范
- 缺少链路追踪信息

**代码示例**:

```go
// 当前实现: 不规范的日志
fmt.Printf("[done] indexing file: %s, len of parts: %d\n", path, len(ids))
log.Printf("Querying Prometheus active alerts")
```

### 2.2 改进方案

**使用结构化日志**:

```go
package logger

import (
    "context"
    
    "github.com/gogf/gf/v2/os/glog"
    "github.com/google/uuid"
)

// 日志字段
type Fields map[string]interface{}

// 日志器
type Logger struct {
    logger *glog.Logger
}

func NewLogger() *Logger {
    return &Logger{
        logger: glog.New(),
    }
}

// 从上下文获取 TraceID
func getTraceID(ctx context.Context) string {
    if traceID := ctx.Value("trace_id"); traceID != nil {
        return traceID.(string)
    }
    return uuid.New().String()
}

// Info 级别日志
func (l *Logger) Info(ctx context.Context, msg string, fields Fields) {
    fields["trace_id"] = getTraceID(ctx)
    l.logger.Info(ctx, msg, fields)
}

// Error 级别日志
func (l *Logger) Error(ctx context.Context, msg string, err error, fields Fields) {
    if fields == nil {
        fields = make(Fields)
    }
    fields["trace_id"] = getTraceID(ctx)
    fields["error"] = err.Error()
    l.logger.Error(ctx, msg, fields)
}

// Debug 级别日志
func (l *Logger) Debug(ctx context.Context, msg string, fields Fields) {
    fields["trace_id"] = getTraceID(ctx)
    l.logger.Debug(ctx, msg, fields)
}

// Warn 级别日志
func (l *Logger) Warn(ctx context.Context, msg string, fields Fields) {
    fields["trace_id"] = getTraceID(ctx)
    l.logger.Warning(ctx, msg, fields)
}
```

**在代码中使用**:

```go
// internal/controller/chat/chat_v1_file_upload.go
package chat

import (
    "SuperBizAgent/pkg/logger"
)

var log = logger.NewLogger()

func buildIntoIndex(ctx context.Context, path string) error {
    // 开始索引
    log.Info(ctx, "开始构建索引", logger.Fields{
        "file_path": path,
        "operation": "index_build",
    })
    
    r, err := knowledge_index_pipeline.BuildKnowledgeIndexing(ctx)
    if err != nil {
        log.Error(ctx, "构建索引流水线失败", err, logger.Fields{
            "file_path": path,
        })
        return err
    }
    
    // 加载文档
    loader, err := loader2.NewFileLoader(ctx)
    if err != nil {
        log.Error(ctx, "创建文件加载器失败", err, logger.Fields{
            "file_path": path,
        })
        return err
    }
    
    docs, err := loader.Load(ctx, document.Source{URI: path})
    if err != nil {
        log.Error(ctx, "加载文档失败", err, logger.Fields{
            "file_path": path,
        })
        return err
    }
    
    log.Info(ctx, "文档加载成功", logger.Fields{
        "file_path":  path,
        "doc_count":  len(docs),
    })
    
    // 删除旧数据
    cli, err := client.NewMilvusClient(ctx)
    if err != nil {
        log.Error(ctx, "连接 Milvus 失败", err, nil)
        return err
    }
    
    expr := fmt.Sprintf(`metadata["_source"] == "%s"`, docs[0].MetaData["_source"])
    queryResult, err := cli.Query(ctx, common.MilvusCollectionName, []string{}, expr, []string{"id"})
    if err != nil {
        log.Error(ctx, "查询旧数据失败", err, logger.Fields{
            "expression": expr,
        })
        return err
    }
    
    if len(queryResult) > 0 {
        // 提取 ID
        var idsToDelete []string
        for _, column := range queryResult {
            if column.Name() == "id" {
                for i := 0; i < column.Len(); i++ {
                    id, _ := column.GetAsString(i)
                    idsToDelete = append(idsToDelete, id)
                }
            }
        }
        
        // 删除
        if len(idsToDelete) > 0 {
            deleteExpr := fmt.Sprintf(`id in ["%s"]`, strings.Join(idsToDelete, `","`))
            err = cli.Delete(ctx, common.MilvusCollectionName, "", deleteExpr)
            if err != nil {
                log.Warn(ctx, "删除旧数据失败", logger.Fields{
                    "delete_count": len(idsToDelete),
                    "error":        err.Error(),
                })
            } else {
                log.Info(ctx, "删除旧数据成功", logger.Fields{
                    "delete_count": len(idsToDelete),
                    "source":       docs[0].MetaData["_source"],
                })
            }
        }
    }
    
    // 重新索引
    ids, err := r.Invoke(ctx, document.Source{URI: path}, compose.WithCallbacks(log_call_back.LogCallback(nil)))
    if err != nil {
        log.Error(ctx, "索引调用失败", err, logger.Fields{
            "file_path": path,
        })
        return fmt.Errorf("invoke index graph failed: %w", err)
    }
    
    log.Info(ctx, "索引构建完成", logger.Fields{
        "file_path":   path,
        "parts_count": len(ids),
        "operation":   "index_build",
        "status":      "success",
    })
    
    return nil
}
```

### 2.3 改进效果

**日志输出示例**:

```json
{
  "time": "2026-01-20 16:35:00",
  "level": "INFO",
  "trace_id": "abc123-def456",
  "message": "索引构建完成",
  "file_path": "./docs/test.txt",
  "parts_count": 10,
  "operation": "index_build",
  "status": "success"
}
```

**优势**:
1. **结构化**: JSON 格式,易于解析和查询
2. **可追踪**: 包含 trace_id,支持链路追踪
3. **可搜索**: 可以按字段快速检索
4. **可分析**: 方便做日志分析和监控

---

## 三、单元测试完善

### 3.1 当前问题

**现状**:
- 项目缺少单元测试
- 代码改动风险高
- 难以保证代码质量

### 3.2 改进方案

**为核心功能添加单元测试**:

```go
// utility/mem/mem_test.go
package mem

import (
    "testing"
    
    "github.com/cloudwego/eino/schema"
    "github.com/stretchr/testify/assert"
)

func TestSimpleMemory_SetMessages(t *testing.T) {
    // 测试用例
    tests := []struct {
        name           string
        initialMsgs    []*schema.Message
        newMsg         *schema.Message
        maxWindowSize  int
        expectedLength int
    }{
        {
            name:           "添加消息到空会话",
            initialMsgs:    []*schema.Message{},
            newMsg:         schema.UserMessage("你好"),
            maxWindowSize:  6,
            expectedLength: 1,
        },
        {
            name: "添加消息触发滑动窗口",
            initialMsgs: []*schema.Message{
                schema.UserMessage("消息1"),
                schema.SystemMessage("回复1"),
                schema.UserMessage("消息2"),
                schema.SystemMessage("回复2"),
                schema.UserMessage("消息3"),
                schema.SystemMessage("回复3"),
            },
            newMsg:         schema.UserMessage("消息4"),
            maxWindowSize:  6,
            expectedLength: 6,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建会话
            mem := &SimpleMemory{
                ID:            "test_user",
                Messages:      tt.initialMsgs,
                MaxWindowSize: tt.maxWindowSize,
            }
            
            // 添加消息
            mem.SetMessages(tt.newMsg)
            
            // 验证结果
            assert.Equal(t, tt.expectedLength, len(mem.Messages))
            
            // 验证消息配对 (应该是偶数)
            assert.Equal(t, 0, len(mem.Messages)%2)
        })
    }
}

func TestSimpleMemory_GetMessages(t *testing.T) {
    mem := &SimpleMemory{
        ID: "test_user",
        Messages: []*schema.Message{
            schema.UserMessage("你好"),
            schema.SystemMessage("你好!"),
        },
        MaxWindowSize: 6,
    }
    
    msgs := mem.GetMessages()
    
    assert.Equal(t, 2, len(msgs))
    assert.Equal(t, "你好", msgs[0].Content)
    assert.Equal(t, "你好!", msgs[1].Content)
}

func TestGetSimpleMemory(t *testing.T) {
    // 清空全局 Map
    SimpleMemoryMap = make(map[string]*SimpleMemory)
    
    // 第一次获取,应该创建新会话
    mem1 := GetSimpleMemory("user1")
    assert.NotNil(t, mem1)
    assert.Equal(t, "user1", mem1.ID)
    assert.Equal(t, 0, len(mem1.Messages))
    
    // 第二次获取,应该返回同一个会话
    mem2 := GetSimpleMemory("user1")
    assert.Equal(t, mem1, mem2)
    
    // 不同用户,应该返回不同会话
    mem3 := GetSimpleMemory("user2")
    assert.NotEqual(t, mem1, mem3)
}

// 并发测试
func TestSimpleMemory_Concurrent(t *testing.T) {
    mem := &SimpleMemory{
        ID:            "test_user",
        Messages:      []*schema.Message{},
        MaxWindowSize: 100,
    }
    
    // 启动多个 goroutine 并发添加消息
    done := make(chan bool)
    for i := 0; i < 10; i++ {
        go func(id int) {
            for j := 0; j < 10; j++ {
                mem.SetMessages(schema.UserMessage(fmt.Sprintf("消息-%d-%d", id, j)))
            }
            done <- true
        }(i)
    }
    
    // 等待所有 goroutine 完成
    for i := 0; i < 10; i++ {
        <-done
    }
    
    // 验证消息数量
    assert.Equal(t, 100, len(mem.Messages))
}
```

**为 Controller 添加测试**:

```go
// internal/controller/chat/chat_v1_chat_test.go
package chat

import (
    "context"
    "testing"
    
    "SuperBizAgent/api/chat/v1"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock ChatPipeline
type MockChatPipeline struct {
    mock.Mock
}

func (m *MockChatPipeline) Invoke(ctx context.Context, input interface{}) (interface{}, error) {
    args := m.Called(ctx, input)
    return args.Get(0), args.Error(1)
}

func TestControllerV1_Chat(t *testing.T) {
    // 准备测试数据
    req := &v1.ChatReq{
        Id:       "test_user",
        Question: "你好",
    }
    
    // 创建 Controller
    controller := &ControllerV1{}
    
    // 执行测试
    res, err := controller.Chat(context.Background(), req)
    
    // 验证结果
    assert.NoError(t, err)
    assert.NotNil(t, res)
    assert.NotEmpty(t, res.Answer)
}

// 表格驱动测试
func TestControllerV1_Chat_TableDriven(t *testing.T) {
    tests := []struct {
        name        string
        req         *v1.ChatReq
        wantErr     bool
        wantContain string
    }{
        {
            name: "正常对话",
            req: &v1.ChatReq{
                Id:       "user1",
                Question: "你好",
            },
            wantErr:     false,
            wantContain: "",
        },
        {
            name: "空问题",
            req: &v1.ChatReq{
                Id:       "user1",
                Question: "",
            },
            wantErr:     true,
            wantContain: "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            controller := &ControllerV1{}
            res, err := controller.Chat(context.Background(), tt.req)
            
            if tt.wantErr {
                assert.Error(t, err)
            } else {
                assert.NoError(t, err)
                assert.NotNil(t, res)
            }
        })
    }
}
```

**运行测试**:

```bash
# 运行所有测试
go test ./...

# 运行指定包的测试
go test ./utility/mem

# 运行测试并显示覆盖率
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
```

### 3.3 改进效果

**优势**:
1. **代码质量**: 测试保证代码正确性
2. **重构信心**: 有测试保护,放心重构
3. **文档作用**: 测试用例即文档
4. **回归测试**: 防止引入新 bug

**目标覆盖率**:
- 核心业务逻辑: 80%+
- 工具函数: 90%+
- 整体覆盖率: 70%+

---

## 四、代码规范与 Lint

### 4.1 当前问题

**现状**:
- 代码风格不统一
- 缺少代码检查工具
- 潜在的代码问题未被发现

### 4.2 改进方案

**引入 golangci-lint**:

```yaml
# .golangci.yml
run:
  timeout: 5m
  tests: true

linters:
  enable:
    - gofmt          # 格式化检查
    - goimports      # import 排序
    - govet          # go vet 检查
    - errcheck       # 错误检查
    - staticcheck    # 静态分析
    - unused         # 未使用代码
    - gosimple       # 简化建议
    - structcheck    # 结构体字段检查
    - varcheck       # 变量检查
    - ineffassign    # 无效赋值
    - deadcode       # 死代码
    - typecheck      # 类型检查
    - gosec          # 安全检查
    - dupl           # 重复代码
    - goconst        # 常量检查
    - gocyclo        # 圈复杂度
    - misspell       # 拼写检查

linters-settings:
  gocyclo:
    min-complexity: 15  # 最大圈复杂度
  
  goconst:
    min-len: 3
    min-occurrences: 3
  
  dupl:
    threshold: 100
  
  errcheck:
    check-blank: true

issues:
  exclude-rules:
    - path: _test\.go
      linters:
        - errcheck
        - dupl
```

**运行 Lint**:

```bash
# 安装 golangci-lint
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest

# 运行检查
golangci-lint run

# 自动修复
golangci-lint run --fix
```

**CI/CD 集成**:

```yaml
# .github/workflows/lint.yml
name: Lint

on: [push, pull_request]

jobs:
  golangci:
    name: lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-go@v4
        with:
          go-version: '1.24'
      
      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
```

### 4.3 改进效果

**优势**:
1. **代码质量**: 自动发现潜在问题
2. **统一风格**: 保持代码风格一致
3. **安全检查**: 发现安全隐患
4. **持续集成**: CI 自动检查

---

## 五、性能分析工具

### 5.1 添加性能分析

**pprof 集成**:

```go
// main.go
import (
    _ "net/http/pprof"
    "net/http"
)

func main() {
    // ... 其他初始化代码
    
    // 启动 pprof 服务 (仅开发环境)
    if os.Getenv("ENV") == "dev" {
        go func() {
            log.Println("pprof server started at :6060")
            http.ListenAndServe(":6060", nil)
        }()
    }
    
    // ... 启动主服务
}
```

**使用 pprof**:

```bash
# CPU 性能分析
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# 内存分析
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutine 分析
go tool pprof http://localhost:6060/debug/pprof/goroutine

# 生成火焰图
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile
```

---

## 六、总结

### 6.1 改进优先级

**高优先级**:
1. 统一错误处理
2. 结构化日志

**中优先级**:
3. 单元测试 (核心模块)
4. 代码 Lint

**低优先级**:
5. 性能分析工具

### 6.2 预期效果

- **代码质量**: 提升 50%
- **可维护性**: 提升 80%
- **问题定位**: 时间缩短 70%
- **测试覆盖率**: 达到 70%+
