# SuperBizAgent 架构优化建议

## 一、引入消息队列解耦

### 1.1 当前问题

**现状**:
- 文件上传后同步构建索引,用户需要等待
- 索引构建耗时长 (大文件可能需要几分钟)
- 用户体验差,接口超时风险高

**代码位置**: `internal/controller/chat/chat_v1_file_upload.go:60`

```go
// 当前实现: 同步索引
err = buildIntoIndex(ctx, common.FileDir+"/"+newFileName)
if err != nil {
    return nil, gerror.Wrapf(err, "构建知识库失败")
}
```

### 1.2 改进方案

**引入 RabbitMQ/Kafka 消息队列**:

```go
// 改进后: 异步索引
package chat

import (
    "github.com/streadway/amqp"
)

// 文件上传接口
func (c *ControllerV1) FileUpload(ctx context.Context, req *v1.FileUploadReq) (res *v1.FileUploadRes, err error) {
    // 1. 保存文件
    _, err = uploadFile.Save(savePath, false)
    if err != nil {
        return nil, gerror.Wrapf(err, "保存文件失败")
    }
    
    // 2. 发送消息到队列
    task := IndexTask{
        FilePath: savePath,
        FileName: newFileName,
        UserID:   req.UserId,
        TaskID:   uuid.New().String(),
    }
    
    err = c.mq.PublishIndexTask(ctx, task)
    if err != nil {
        return nil, gerror.Wrapf(err, "发送索引任务失败")
    }
    
    // 3. 立即返回,不等待索引完成
    res = &v1.FileUploadRes{
        FileName: newFileName,
        FilePath: savePath,
        FileSize: fileInfo.Size(),
        TaskID:   task.TaskID,  // 返回任务ID供查询进度
        Status:   "indexing",   // 索引中
    }
    return res, nil
}

// 消息队列客户端
type MQClient struct {
    conn    *amqp.Connection
    channel *amqp.Channel
}

func NewMQClient(url string) (*MQClient, error) {
    conn, err := amqp.Dial(url)
    if err != nil {
        return nil, err
    }
    
    channel, err := conn.Channel()
    if err != nil {
        return nil, err
    }
    
    // 声明队列
    _, err = channel.QueueDeclare(
        "index_tasks", // 队列名
        true,          // 持久化
        false,         // 不自动删除
        false,         // 非独占
        false,         // 不等待
        nil,
    )
    
    return &MQClient{conn: conn, channel: channel}, nil
}

func (m *MQClient) PublishIndexTask(ctx context.Context, task IndexTask) error {
    body, err := json.Marshal(task)
    if err != nil {
        return err
    }
    
    return m.channel.Publish(
        "",            // 默认交换机
        "index_tasks", // 路由键
        false,         // 不强制
        false,         // 不立即
        amqp.Publishing{
            DeliveryMode: amqp.Persistent,
            ContentType:  "application/json",
            Body:         body,
        },
    )
}

// 索引任务消费者 (独立进程)
type IndexWorker struct {
    mq *MQClient
}

func (w *IndexWorker) Start(ctx context.Context) error {
    msgs, err := w.mq.channel.Consume(
        "index_tasks", // 队列名
        "",            // 消费者标签
        false,         // 手动确认
        false,         // 非独占
        false,         // 不等待
        false,         // 不阻塞
        nil,
    )
    if err != nil {
        return err
    }
    
    // 启动多个 worker 并发处理
    for i := 0; i < 5; i++ {
        go w.processMessages(ctx, msgs)
    }
    
    return nil
}

func (w *IndexWorker) processMessages(ctx context.Context, msgs <-chan amqp.Delivery) {
    for msg := range msgs {
        var task IndexTask
        if err := json.Unmarshal(msg.Body, &task); err != nil {
            log.Printf("解析任务失败: %v", err)
            msg.Nack(false, false) // 拒绝消息,不重新入队
            continue
        }
        
        // 执行索引构建
        err := buildIntoIndex(ctx, task.FilePath)
        if err != nil {
            log.Printf("索引构建失败: %v", err)
            msg.Nack(false, true) // 拒绝消息,重新入队
            continue
        }
        
        // 更新任务状态
        updateTaskStatus(ctx, task.TaskID, "completed")
        
        // 确认消息
        msg.Ack(false)
    }
}
```

### 1.3 改进效果

**优势**:
1. **用户体验提升**: 文件上传立即返回,无需等待
2. **系统解耦**: 上传和索引分离,互不影响
3. **可扩展性**: 可以启动多个 worker 并发处理
4. **可靠性**: 消息持久化,任务不丢失
5. **可观测性**: 可以查询任务进度

**性能对比**:
- 改进前: 上传接口响应时间 30s+ (包含索引)
- 改进后: 上传接口响应时间 < 1s (仅保存文件)

---

## 二、分布式会话管理

### 2.1 当前问题

**现状**:
- 会话存储在内存 Map 中
- 单实例部署,无法水平扩展
- 服务重启会话丢失

**代码位置**: `utility/mem/mem.go`

```go
// 当前实现: 内存存储
var SimpleMemoryMap = make(map[string]*SimpleMemory)

func GetSimpleMemory(id string) *SimpleMemory {
    mu.Lock()
    defer mu.Unlock()
    if mem, ok := SimpleMemoryMap[id]; ok {
        return mem
    }
    // ...
}
```

### 2.2 改进方案

**使用 Redis 存储会话**:

```go
package mem

import (
    "context"
    "encoding/json"
    "time"
    
    "github.com/go-redis/redis/v8"
    "github.com/cloudwego/eino/schema"
)

// Redis 客户端
type RedisMemoryStore struct {
    client *redis.Client
    ttl    time.Duration
}

func NewRedisMemoryStore(addr string, password string) (*RedisMemoryStore, error) {
    client := redis.NewClient(&redis.Options{
        Addr:     addr,
        Password: password,
        DB:       0,
    })
    
    // 测试连接
    ctx := context.Background()
    if err := client.Ping(ctx).Err(); err != nil {
        return nil, err
    }
    
    return &RedisMemoryStore{
        client: client,
        ttl:    24 * time.Hour, // 会话保留 24 小时
    }, nil
}

// 获取会话
func (r *RedisMemoryStore) GetMemory(ctx context.Context, id string) (*SimpleMemory, error) {
    key := "session:" + id
    
    // 从 Redis 获取
    data, err := r.client.Get(ctx, key).Result()
    if err == redis.Nil {
        // 会话不存在,创建新的
        return &SimpleMemory{
            ID:            id,
            Messages:      []*schema.Message{},
            MaxWindowSize: 6,
        }, nil
    }
    if err != nil {
        return nil, err
    }
    
    // 反序列化
    var mem SimpleMemory
    if err := json.Unmarshal([]byte(data), &mem); err != nil {
        return nil, err
    }
    
    return &mem, nil
}

// 保存会话
func (r *RedisMemoryStore) SaveMemory(ctx context.Context, mem *SimpleMemory) error {
    key := "session:" + mem.ID
    
    // 序列化
    data, err := json.Marshal(mem)
    if err != nil {
        return err
    }
    
    // 保存到 Redis,设置过期时间
    return r.client.Set(ctx, key, data, r.ttl).Err()
}

// 添加消息
func (r *RedisMemoryStore) AddMessage(ctx context.Context, id string, msg *schema.Message) error {
    // 1. 获取当前会话
    mem, err := r.GetMemory(ctx, id)
    if err != nil {
        return err
    }
    
    // 2. 添加消息
    mem.Messages = append(mem.Messages, msg)
    
    // 3. 滑动窗口处理
    if len(mem.Messages) > mem.MaxWindowSize {
        excess := len(mem.Messages) - mem.MaxWindowSize
        if excess%2 != 0 {
            excess++
        }
        mem.Messages = mem.Messages[excess:]
    }
    
    // 4. 保存回 Redis
    return r.SaveMemory(ctx, mem)
}

// 获取消息历史
func (r *RedisMemoryStore) GetMessages(ctx context.Context, id string) ([]*schema.Message, error) {
    mem, err := r.GetMemory(ctx, id)
    if err != nil {
        return nil, err
    }
    return mem.Messages, nil
}

// 清除会话
func (r *RedisMemoryStore) ClearMemory(ctx context.Context, id string) error {
    key := "session:" + id
    return r.client.Del(ctx, key).Err()
}

// 设置会话过期时间
func (r *RedisMemoryStore) SetExpire(ctx context.Context, id string, ttl time.Duration) error {
    key := "session:" + id
    return r.client.Expire(ctx, key, ttl).Err()
}
```

**使用示例**:

```go
// 初始化 Redis 存储
var memStore *mem.RedisMemoryStore

func init() {
    var err error
    memStore, err = mem.NewRedisMemoryStore("localhost:6379", "")
    if err != nil {
        panic(err)
    }
}

// 在 Controller 中使用
func (c *ControllerV1) Chat(ctx context.Context, req *v1.ChatReq) (res *v1.ChatRes, err error) {
    // 获取历史消息
    history, err := memStore.GetMessages(ctx, req.Id)
    if err != nil {
        return nil, err
    }
    
    userMessage := &chat_pipeline.UserMessage{
        ID:      req.Id,
        Query:   req.Question,
        History: history,
    }
    
    // ... 执行推理
    
    // 保存对话历史
    err = memStore.AddMessage(ctx, req.Id, schema.UserMessage(msg))
    if err != nil {
        log.Printf("保存用户消息失败: %v", err)
    }
    
    err = memStore.AddMessage(ctx, req.Id, schema.SystemMessage(out.Content))
    if err != nil {
        log.Printf("保存系统消息失败: %v", err)
    }
    
    return res, nil
}
```

### 2.3 改进效果

**优势**:
1. **水平扩展**: 支持多实例部署,共享会话
2. **持久化**: 服务重启会话不丢失
3. **高可用**: Redis 主从/集群保证可用性
4. **过期管理**: 自动清理过期会话
5. **分布式锁**: 可以使用 Redis 实现分布式锁

**配置示例**:

```yaml
# hack/config.yaml
redis:
  addr: "localhost:6379"
  password: ""
  db: 0
  pool_size: 10
  session_ttl: "24h"
```

---

## 三、缓存层优化

### 3.1 当前问题

**现状**:
- 每次对话都要检索向量数据库
- 相同问题重复检索,浪费资源
- 热点问题响应慢

### 3.2 改进方案

**引入多级缓存**:

```go
package cache

import (
    "context"
    "crypto/md5"
    "encoding/hex"
    "encoding/json"
    "time"
    
    "github.com/go-redis/redis/v8"
    "github.com/patrickmn/go-cache"
)

// 多级缓存管理器
type CacheManager struct {
    local  *cache.Cache      // 本地缓存 (内存)
    redis  *redis.Client     // 分布式缓存 (Redis)
    enable bool
}

func NewCacheManager(redisAddr string, enable bool) (*CacheManager, error) {
    if !enable {
        return &CacheManager{enable: false}, nil
    }
    
    // 本地缓存: 5分钟过期,10分钟清理
    localCache := cache.New(5*time.Minute, 10*time.Minute)
    
    // Redis 缓存
    redisClient := redis.NewClient(&redis.Options{
        Addr: redisAddr,
    })
    
    return &CacheManager{
        local:  localCache,
        redis:  redisClient,
        enable: true,
    }, nil
}

// 生成缓存键
func (c *CacheManager) generateKey(prefix string, data interface{}) string {
    jsonData, _ := json.Marshal(data)
    hash := md5.Sum(jsonData)
    return prefix + ":" + hex.EncodeToString(hash[:])
}

// 获取 RAG 检索结果缓存
func (c *CacheManager) GetRAGCache(ctx context.Context, query string) ([]string, bool) {
    if !c.enable {
        return nil, false
    }
    
    key := c.generateKey("rag", query)
    
    // 1. 先查本地缓存 (L1)
    if val, found := c.local.Get(key); found {
        return val.([]string), true
    }
    
    // 2. 再查 Redis 缓存 (L2)
    data, err := c.redis.Get(ctx, key).Result()
    if err == nil {
        var docs []string
        if err := json.Unmarshal([]byte(data), &docs); err == nil {
            // 回填本地缓存
            c.local.Set(key, docs, cache.DefaultExpiration)
            return docs, true
        }
    }
    
    return nil, false
}

// 设置 RAG 检索结果缓存
func (c *CacheManager) SetRAGCache(ctx context.Context, query string, docs []string) error {
    if !c.enable {
        return nil
    }
    
    key := c.generateKey("rag", query)
    
    // 1. 设置本地缓存
    c.local.Set(key, docs, cache.DefaultExpiration)
    
    // 2. 设置 Redis 缓存 (1小时)
    data, err := json.Marshal(docs)
    if err != nil {
        return err
    }
    
    return c.redis.Set(ctx, key, data, time.Hour).Err()
}

// 获取 LLM 响应缓存
func (c *CacheManager) GetLLMCache(ctx context.Context, prompt string) (string, bool) {
    if !c.enable {
        return "", false
    }
    
    key := c.generateKey("llm", prompt)
    
    // 只查 Redis (LLM 响应较大,不放本地缓存)
    data, err := c.redis.Get(ctx, key).Result()
    if err == nil {
        return data, true
    }
    
    return "", false
}

// 设置 LLM 响应缓存
func (c *CacheManager) SetLLMCache(ctx context.Context, prompt string, response string) error {
    if !c.enable {
        return nil
    }
    
    key := c.generateKey("llm", prompt)
    
    // 缓存 30 分钟
    return c.redis.Set(ctx, key, response, 30*time.Minute).Err()
}

// 清除缓存
func (c *CacheManager) Clear(ctx context.Context, pattern string) error {
    // 清除本地缓存
    c.local.Flush()
    
    // 清除 Redis 缓存
    iter := c.redis.Scan(ctx, 0, pattern, 0).Iterator()
    for iter.Next(ctx) {
        c.redis.Del(ctx, iter.Val())
    }
    
    return iter.Err()
}
```

**在 RAG 流程中使用缓存**:

```go
// internal/ai/agent/chat_pipeline/retriever.go

func newRetriever(ctx context.Context) (retriever.Retriever, error) {
    // 初始化缓存
    cacheManager, err := cache.NewCacheManager("localhost:6379", true)
    if err != nil {
        return nil, err
    }
    
    // 包装原始 Retriever
    baseRetriever, err := milvus.NewMilvusRetriever(ctx, config)
    if err != nil {
        return nil, err
    }
    
    // 返回带缓存的 Retriever
    return &CachedRetriever{
        base:  baseRetriever,
        cache: cacheManager,
    }, nil
}

type CachedRetriever struct {
    base  retriever.Retriever
    cache *cache.CacheManager
}

func (r *CachedRetriever) Retrieve(ctx context.Context, query string) ([]string, error) {
    // 1. 尝试从缓存获取
    if docs, found := r.cache.GetRAGCache(ctx, query); found {
        log.Printf("缓存命中: %s", query)
        return docs, nil
    }
    
    // 2. 缓存未命中,执行检索
    docs, err := r.base.Retrieve(ctx, query)
    if err != nil {
        return nil, err
    }
    
    // 3. 写入缓存
    if err := r.cache.SetRAGCache(ctx, query, docs); err != nil {
        log.Printf("缓存写入失败: %v", err)
    }
    
    return docs, nil
}
```

### 3.3 改进效果

**优势**:
1. **响应速度**: 缓存命中时延迟降低 90%
2. **资源节省**: 减少向量数据库查询压力
3. **成本降低**: 减少 LLM API 调用次数
4. **多级缓存**: 本地缓存 + Redis 缓存

**性能对比**:
- 无缓存: RAG 检索 50ms + LLM 推理 2s = 2050ms
- 有缓存: 缓存读取 5ms = 5ms (提升 400 倍)

**缓存命中率监控**:

```go
// 添加监控指标
type CacheMetrics struct {
    Hits   int64
    Misses int64
}

func (c *CacheManager) GetHitRate() float64 {
    total := c.metrics.Hits + c.metrics.Misses
    if total == 0 {
        return 0
    }
    return float64(c.metrics.Hits) / float64(total)
}
```

---

## 四、总结

### 4.1 改进优先级

**高优先级** (立即实施):
1. Redis 会话管理 - 支持水平扩展
2. 缓存层优化 - 提升响应速度

**中优先级** (3个月内):
1. 消息队列解耦 - 提升用户体验

### 4.2 预期效果

| 指标 | 改进前 | 改进后 | 提升 |
|------|--------|--------|------|
| 文件上传响应 | 30s | < 1s | 30倍 |
| 对话响应时间 | 2s | 200ms | 10倍 |
| 并发支持 | 100 QPS | 1000 QPS | 10倍 |
| 可用性 | 单点故障 | 高可用 | - |

### 4.3 实施建议

1. **分阶段实施**: 先 Redis,再缓存,最后消息队列
2. **灰度发布**: 小流量验证后再全量
3. **监控告警**: 添加关键指标监控
4. **文档更新**: 更新部署和运维文档
