# SuperBizAgent 项目整体架构与核心功能

## 一、项目概述

### 1.1 项目背景
SuperBizAgent 是一个基于 AI 的企业级运维自动化助手,旨在解决传统 OnCall 值班中人工值守和排查问题的低效痛点。

### 1.2 核心价值
- **降低人力成本**: 自动化处理常见告警和问题
- **提升响应速度**: 7x24小时智能值守,秒级响应
- **知识沉淀**: 将运维经验转化为可检索的知识库
- **智能决策**: 基于历史数据和文档自动生成处理方案

### 1.3 三大核心 Agent
1. **知识库 Agent**: 负责文档索引和知识检索
2. **对话 Agent**: 提供智能对话和问题解答
3. **运维 Agent**: 自动化告警分析和故障排查

---

## 二、技术架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        前端层 (Frontend)                      │
│                    SuperBizAgentFrontend                      │
│                  (HTML + JavaScript + CSS)                    │
└────────────────────────┬────────────────────────────────────┘
                         │ HTTP/SSE
┌────────────────────────┴────────────────────────────────────┐
│                      API 网关层 (GoFrame)                     │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Middleware: CORS + Response + SSE                   │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Controller: Chat API (v1)                           │   │
│  │  - /api/chat          (普通对话)                      │   │
│  │  - /api/chat_stream   (流式对话)                      │   │
│  │  - /api/upload        (文件上传)                      │   │
│  │  - /api/ai_ops        (AI运维)                        │   │
│  └──────────────────────────────────────────────────────┘   │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────┴────────────────────────────────────┐
│                      业务逻辑层 (Logic)                       │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Chat Pipeline (对话流水线)                           │   │
│  │  - 用户输入处理                                        │   │
│  │  - RAG 知识检索                                        │   │
│  │  - ReAct Agent 推理                                   │   │
│  │  - 工具调用编排                                        │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Knowledge Index Pipeline (知识索引流水线)             │   │
│  │  - 文件加载                                            │   │
│  │  - Markdown 分割                                       │   │
│  │  - 向量化索引                                          │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  Plan-Execute-Replan (计划执行重规划)                  │   │
│  │  - 任务规划                                            │   │
│  │  - 工具执行                                            │   │
│  │  - 动态重规划                                          │   │
│  └──────────────────────────────────────────────────────┘   │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────┴────────────────────────────────────┐
│                      AI 能力层 (AI Layer)                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │
│  │  LLM Model  │  │  Embedder   │  │  Tools (工具集)      │ │
│  │  (OpenAI)   │  │  (Ark)      │  │  - Prometheus查询   │ │
│  │             │  │             │  │  - MySQL CRUD       │ │
│  │             │  │             │  │  - 日志查询(MCP)    │ │
│  │             │  │             │  │  - 内部文档检索     │ │
│  │             │  │             │  │  - 时间工具         │ │
│  └─────────────┘  └─────────────┘  └─────────────────────┘ │
└────────────────────────┬────────────────────────────────────┘
                         │
┌────────────────────────┴────────────────────────────────────┐
│                      数据存储层 (Storage)                     │
│  ┌─────────────────┐           ┌─────────────────────────┐  │
│  │  Milvus         │           │  MySQL                  │  │
│  │  (向量数据库)    │           │  (关系数据库)            │  │
│  │  - 知识库向量    │           │  - 业务数据              │  │
│  │  - 文档检索      │           │                         │  │
│  └─────────────────┘           └─────────────────────────┘  │
│  ┌─────────────────┐           ┌─────────────────────────┐  │
│  │  Memory Store   │           │  Prometheus             │  │
│  │  (内存会话)      │           │  (监控告警)              │  │
│  │  - 对话历史      │           │                         │  │
│  └─────────────────┘           └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心技术栈

#### 后端框架
- **GoFrame v2.7.1**: 企业级 Go 开发框架,提供完整的 MVC 架构
- **Go 1.24.0**: 最新版本 Go 语言

#### AI 框架
- **Eino v0.5.7**: 字节跳动开源的 AI 编排框架,核心能力
- **Eino-ext**: Eino 的扩展组件库
  - embedding/ark: 向量化能力
  - model/openai: LLM 模型接入
  - tool/mcp: MCP 协议工具集成
  - retriever/milvus: 向量检索

#### 数据存储
- **Milvus v2.4.2**: 向量数据库,存储知识库向量
- **MySQL**: 关系型数据库,存储业务数据
- **GORM v1.31.0**: Go ORM 框架

#### 其他核心依赖
- **MCP-Go v0.42.0**: Model Context Protocol 客户端
- **Prometheus**: 监控告警系统集成

---

## 三、核心功能详解

### 3.1 智能对话功能 (Chat)

#### 功能描述
提供基于 RAG (检索增强生成) 的智能对话能力,支持普通对话和流式对话。

#### 技术实现

**核心代码位置**: `internal/controller/chat/chat_v1_chat.go`

```go
func (c *ControllerV1) Chat(ctx context.Context, req *v1.ChatReq) (res *v1.ChatRes, err error) {
    // 1. 获取用户输入和历史对话
    userMessage := &chat_pipeline.UserMessage{
        ID:      req.Id,
        Query:   req.Question,
        History: mem.GetSimpleMemory(req.Id).GetMessages(),
    }
    
    // 2. 构建 Chat Agent
    runner, err := chat_pipeline.BuildChatAgent(ctx)
    
    // 3. 执行推理
    out, err := runner.Invoke(ctx, userMessage, compose.WithCallbacks(log_call_back.LogCallback(nil)))
    
    // 4. 保存对话历史
    mem.GetSimpleMemory(id).SetMessages(schema.UserMessage(msg))
    mem.GetSimpleMemory(id).SetMessages(schema.SystemMessage(out.Content))
    
    return res, nil
}
```

#### 数据流转

```
用户输入 
  ↓
获取历史对话 (Memory)
  ↓
构建 UserMessage
  ↓
Chat Pipeline 处理
  ├─ InputToRag: 提取查询关键词
  ├─ MilvusRetriever: 检索相关文档
  ├─ InputToChat: 构建对话上下文
  ├─ ChatTemplate: 填充 Prompt 模板
  └─ ReactAgent: LLM 推理 + 工具调用
  ↓
返回结果 + 更新历史
```

#### 关键特性
- **会话管理**: 基于用户 ID 维护独立的对话历史
- **滑动窗口**: 最多保留 6 条历史消息,防止上下文过长
- **RAG 增强**: 自动检索知识库相关文档,提升回答准确性
- **工具调用**: 支持调用 Prometheus、MySQL、日志查询等工具

---

### 3.2 流式对话功能 (Chat Stream)

#### 功能描述
支持 SSE (Server-Sent Events) 流式输出,实时返回 AI 生成内容,提升用户体验。

#### 技术实现

**核心代码位置**: `internal/controller/chat/chat_v1_chat_stream.go`

```go
func (c *ControllerV1) ChatStream(ctx context.Context, req *v1.ChatStreamReq) (res *v1.ChatStreamRes, err error) {
    // 1. 创建 SSE 客户端
    client, err := c.service.Create(ctx, g.RequestFromCtx(ctx))
    
    // 2. 启动流式推理
    sr, err := runner.Stream(ctx, userMessage, compose.WithCallbacks(log_call_back.LogCallback(nil)))
    defer sr.Close()
    
    var fullResponse strings.Builder
    
    // 3. 逐块接收并发送
    for {
        chunk, err := sr.Recv()
        if errors.Is(err, io.EOF) {
            client.SendToClient("done", "Stream completed")
            return &v1.ChatStreamRes{}, nil
        }
        fullResponse.WriteString(chunk.Content)
        client.SendToClient("message", chunk.Content)
    }
}
```

#### SSE 通信流程

```
客户端发起请求
  ↓
服务端创建 SSE 连接
  ↓
启动流式推理
  ↓
循环接收 Token
  ├─ 每收到一个 chunk
  ├─ 立即通过 SSE 发送给客户端
  └─ 累积完整响应
  ↓
推理结束发送 "done" 事件
  ↓
保存完整对话历史
```

#### 关键特性
- **实时响应**: 逐 Token 返回,无需等待完整生成
- **连接管理**: 基于 client_id 管理多个并发连接
- **完整保存**: 流式输出完成后统一保存完整对话

---

### 3.3 知识库管理 (File Upload)

#### 功能描述
支持上传文档文件,自动进行向量化索引,构建可检索的知识库。

#### 技术实现

**核心代码位置**: `internal/controller/chat/chat_v1_file_upload.go`

```go
func (c *ControllerV1) FileUpload(ctx context.Context, req *v1.FileUploadReq) (res *v1.FileUploadRes, err error) {
    // 1. 接收文件上传
    uploadFile := r.GetUploadFile("file")
    
    // 2. 保存文件到本地
    _, err = uploadFile.Save(savePath, false)
    
    // 3. 构建知识索引
    err = buildIntoIndex(ctx, common.FileDir+"/"+newFileName)
    
    return res, nil
}

func buildIntoIndex(ctx context.Context, path string) error {
    // 1. 构建索引流水线
    r, err := knowledge_index_pipeline.BuildKnowledgeIndexing(ctx)
    
    // 2. 加载文档
    loader, err := loader2.NewFileLoader(ctx)
    docs, err := loader.Load(ctx, document.Source{URI: path})
    
    // 3. 删除旧数据 (相同 _source)
    expr := fmt.Sprintf(`metadata["_source"] == "%s"`, docs[0].MetaData["_source"])
    queryResult, err := cli.Query(ctx, common.MilvusCollectionName, []string{}, expr, []string{"id"})
    // ... 删除逻辑
    
    // 4. 重新索引
    ids, err := r.Invoke(ctx, document.Source{URI: path}, compose.WithCallbacks(log_call_back.LogCallback(nil)))
    
    return nil
}
```

#### 知识索引流水线

**核心代码位置**: `internal/ai/agent/knowledge_index_pipeline/orchestration.go`

```
文件上传
  ↓
FileLoader: 加载文件内容
  ↓
MarkdownSplitter: 按语义分割文档
  ↓
Embedding: 向量化文本
  ↓
MilvusIndexer: 存入向量数据库
  ↓
索引完成
```

#### 关键特性
- **增量更新**: 上传同名文件时自动删除旧版本
- **语义分割**: 使用 Markdown Splitter 保持文档结构
- **向量检索**: 支持语义相似度搜索

---

### 3.4 AI 运维功能 (AIOps)

#### 功能描述
自动化告警分析和故障排查,基于 Plan-Execute-Replan 模式实现复杂任务编排。

#### 技术实现

**核心代码位置**: `internal/controller/chat/chat_v1_ai_ops.go`

```go
func (c *ControllerV1) AIOps(ctx context.Context, req *v1.AIOpsReq) (res *v1.AIOpsRes, err error) {
    query := `
    1. 调用 query_prometheus_alerts 获取所有活跃告警
    2. 根据告警名称调用 query_internal_docs 获取处理方案
    3. 完全遵循内部文档内容进行分析
    4. 涉及时间参数先调用 get_current_time
    5. 涉及日志查询需携带地域和日志主题
    6. 生成告警运维分析报告
    `
    
    resp, detail, err := plan_execute_replan.BuildPlanAgent(ctx, query)
    
    res = &v1.AIOpsRes{
        Result: resp,
        Detail: detail,
    }
    return res, nil
}
```

#### Plan-Execute-Replan 流程

**核心代码位置**: `internal/ai/agent/plan_execute_replan/plan_execute_replan.go`

```
用户任务
  ↓
Planner: 制定执行计划
  ├─ 步骤1: 查询告警
  ├─ 步骤2: 检索文档
  └─ 步骤3: 生成报告
  ↓
Executor: 执行单个步骤
  ├─ 调用工具
  └─ 收集结果
  ↓
Replanner: 根据执行结果重新规划
  ├─ 判断是否需要调整计划
  └─ 生成新的执行步骤
  ↓
循环执行 (最多20次迭代)
  ↓
返回最终结果
```

#### 可用工具集

1. **query_prometheus_alerts**: 查询 Prometheus 活跃告警
2. **query_internal_docs**: 检索内部文档和处理方案
3. **mysql_crud**: 执行 MySQL 数据库操作
4. **get_current_time**: 获取当前时间
5. **MCP 日志工具**: 通过 MCP 协议查询日志

#### 关键特性
- **自动编排**: 根据任务自动规划执行步骤
- **动态调整**: 根据执行结果实时调整计划
- **工具组合**: 灵活组合多个工具完成复杂任务
- **详细追踪**: 记录每个步骤的执行细节

---

## 四、核心目录结构

```
SuperBizAgent/
├── main.go                      # 程序入口,初始化服务器
├── go.mod                       # Go 模块依赖管理
├── api/                         # API 接口定义层
│   └── chat/
│       ├── chat.go             # 接口定义
│       └── v1/
│           └── chat.go         # v1 版本请求/响应结构
├── internal/                    # 内部业务逻辑
│   ├── controller/             # 控制器层
│   │   └── chat/
│   │       ├── chat_v1_chat.go          # 普通对话
│   │       ├── chat_v1_chat_stream.go   # 流式对话
│   │       ├── chat_v1_file_upload.go   # 文件上传
│   │       └── chat_v1_ai_ops.go        # AI运维
│   ├── logic/                  # 业务逻辑层
│   │   └── chat/
│   ├── ai/                     # AI 能力层
│   │   ├── agent/             # Agent 编排
│   │   │   ├── chat_pipeline/           # 对话流水线
│   │   │   ├── knowledge_index_pipeline/ # 知识索引流水线
│   │   │   └── plan_execute_replan/     # 计划执行重规划
│   │   ├── models/            # LLM 模型
│   │   ├── embedder/          # 向量化
│   │   ├── retriever/         # 检索器
│   │   ├── indexer/           # 索引器
│   │   ├── loader/            # 文档加载器
│   │   └── tools/             # 工具集
│   │       ├── query_metrics_alerts.go  # Prometheus告警查询
│   │       ├── query_internal_docs.go   # 内部文档检索
│   │       ├── mysql_crud.go            # MySQL操作
│   │       ├── get_current_time.go      # 时间工具
│   │       └── query_log.go             # 日志查询
│   └── consts/                # 常量定义
├── utility/                    # 工具类
│   ├── client/                # 客户端 (Milvus等)
│   ├── common/                # 公共常量
│   ├── mem/                   # 内存会话管理
│   ├── middleware/            # 中间件 (CORS, Response)
│   └── log_call_back/         # 日志回调
├── manifest/                   # 部署配置
│   └── docker/
├── hack/                       # 开发配置
│   └── config.yaml
├── docs/                       # 文档目录
└── SuperBizAgentFrontend/      # 前端代码
```

---

## 五、数据流转全景

### 5.1 对话请求完整流程

```
1. 前端发起请求
   POST /api/chat_stream
   Body: { "id": "user123", "question": "查询告警" }
   
2. 中间件处理
   ├─ CORS: 跨域处理
   └─ Response: 统一响应格式
   
3. Controller 层
   ├─ 解析请求参数
   ├─ 创建 SSE 连接
   └─ 调用 Logic 层
   
4. Chat Pipeline 编排
   ├─ InputToRag: 提取查询词 "告警"
   ├─ MilvusRetriever: 检索相关文档
   │   └─ 查询 Milvus 向量数据库
   ├─ InputToChat: 构建对话上下文
   │   └─ 获取历史对话 (Memory)
   ├─ ChatTemplate: 填充 Prompt
   │   ├─ System Prompt
   │   ├─ 历史对话
   │   ├─ 检索文档
   │   └─ 用户问题
   └─ ReactAgent: LLM 推理
       ├─ 分析是否需要调用工具
       ├─ 调用 query_prometheus_alerts
       ├─ 获取告警列表
       ├─ 生成回答
       └─ 流式返回
       
5. 响应返回
   ├─ SSE 流式推送每个 Token
   ├─ 前端实时显示
   └─ 完成后保存对话历史
```

### 5.2 知识库索引流程

```
1. 用户上传文件
   POST /api/upload
   FormData: file
   
2. 文件保存
   └─ 保存到 ./docs/ 目录
   
3. Knowledge Index Pipeline
   ├─ FileLoader: 读取文件内容
   │   └─ 支持 txt, md, pdf 等格式
   ├─ MarkdownSplitter: 语义分割
   │   ├─ 按标题层级分割
   │   ├─ 保持上下文连贯
   │   └─ 控制分块大小
   ├─ Embedder: 向量化
   │   ├─ 调用 Ark Embedding API
   │   └─ 生成 81920 维二值向量
   └─ MilvusIndexer: 存储
       ├─ 连接 Milvus (localhost:19530)
       ├─ 检查并创建 Collection
       ├─ 删除同名文档旧数据
       └─ 插入新向量数据
       
4. 索引完成
   └─ 返回索引的文档片段数量
```

### 5.3 AI 运维分析流程

```
1. 触发 AI 运维
   POST /api/ai_ops
   
2. Plan-Execute-Replan Agent
   ├─ Planner: 制定计划
   │   ├─ 步骤1: 查询活跃告警
   │   ├─ 步骤2: 检索处理文档
   │   └─ 步骤3: 生成分析报告
   │
   ├─ Executor: 执行步骤1
   │   ├─ 调用 query_prometheus_alerts
   │   ├─ 获取告警列表
   │   │   [
   │   │     { "alert_name": "HighCPU", "state": "firing" },
   │   │     { "alert_name": "DiskFull", "state": "firing" }
   │   │   ]
   │   └─ 返回执行结果
   │
   ├─ Replanner: 评估结果
   │   ├─ 发现有2个告警
   │   └─ 调整计划: 分别查询每个告警的文档
   │
   ├─ Executor: 执行步骤2.1
   │   ├─ 调用 query_internal_docs("HighCPU")
   │   ├─ 检索 Milvus 知识库
   │   └─ 返回处理方案文档
   │
   ├─ Executor: 执行步骤2.2
   │   ├─ 调用 query_internal_docs("DiskFull")
   │   └─ 返回处理方案文档
   │
   ├─ Replanner: 评估结果
   │   ├─ 已获取所有告警的处理方案
   │   └─ 继续执行最后步骤
   │
   └─ Executor: 执行步骤3
       ├─ 汇总所有信息
       ├─ 生成 Markdown 格式报告
       │   # 告警分析报告
       │   ## 活跃告警清单
       │   ## 告警根因分析1: HighCPU
       │   ## 处理方案执行1
       │   ## 告警根因分析2: DiskFull
       │   ## 处理方案执行2
       │   ## 结论
       └─ 返回完整报告
       
3. 返回结果
   {
     "result": "完整的分析报告",
     "detail": ["步骤1输出", "步骤2输出", ...]
   }
```

---

## 六、核心设计亮点

### 6.1 Graph 编排架构
使用 Eino 的 Graph 编排能力,将复杂的 AI 流程拆解为可组合的节点:
- **Lambda Node**: 自定义逻辑处理
- **ChatTemplate Node**: Prompt 模板填充
- **Retriever Node**: 向量检索
- **Agent Node**: ReAct 推理

### 6.2 会话管理
- 基于用户 ID 的独立会话空间
- 滑动窗口机制控制上下文长度
- 线程安全的并发访问

### 6.3 RAG 增强
- 自动提取查询关键词
- 向量相似度检索相关文档
- 文档内容注入 Prompt 上下文

### 6.4 工具调用
- ReAct 模式自主决策工具调用
- 支持多工具组合使用
- MCP 协议集成外部工具

### 6.5 流式输出
- SSE 协议实现实时推送
- 逐 Token 返回提升体验
- 连接管理支持多用户并发

---

## 七、面试讲解要点

### 7.1 项目定位
"这是一个企业级 AI 运维助手,核心解决 OnCall 值班的人力成本和响应速度问题。通过整合知识库检索、智能对话和自动化运维三大能力,实现 7x24 小时智能值守。"

### 7.2 技术选型
"后端使用 GoFrame 框架保证开发效率,AI 能力基于字节跳动的 Eino 框架实现编排。选择 Milvus 作为向量数据库是因为它对二值向量的高效支持,相比浮点向量节省存储和计算成本。"

### 7.3 架构设计
"采用分层架构: API 层负责接口暴露,Controller 层处理请求,Logic 层编排 AI 流程,AI 层封装各种能力组件。这样的分层保证了代码的可维护性和可测试性。"

### 7.4 核心难点
"主要难点在于 AI Agent 的编排。我们使用 Graph 模式将复杂流程拆解为节点,通过边连接实现数据流转。比如对话流程中,同时启动 RAG 检索和对话上下文构建,最后在 ChatTemplate 节点汇聚,提升了并行度。"

### 7.5 性能优化
"向量检索使用二值向量,相比浮点向量存储减少 32 倍。会话管理采用滑动窗口,避免上下文无限增长。流式输出降低首字延迟,提升用户体验。"
